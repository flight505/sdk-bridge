I'll analyze this thoroughly. Let me first explore the SDK Bridge codebase to understand the current architecture and then create a comprehensive plan.Let me also examine the hybrid loop agent and CLAUDE.md for more context:Now let me look at one more critical piece - the existing skill structure to understand the pattern:Now I have a comprehensive understanding of the SDK Bridge architecture. Let me create a detailed natural language plan for transforming it from "execution engine requiring manual planning" to "end-to-end autonomous development assistant."

---

# SDK Bridge v3.0: Assisted Decomposition Layer - Final Plan

## Executive Summary

The core problem: SDK Bridge requires a perfectly structured `feature_list.json` before execution, but provides no tooling to help users create it. This inverts the UX - users must do the hardest part (task decomposition) with the least support.

The solution: Insert an **Assisted Decomposition Layer** between user intent and agent execution. This transforms `/sdk-bridge:start` from "launch agent with existing plan" to "what do you want to build? → decompose → validate → launch."

---

## Architecture Overview

### Current Flow (v2.x)
```
User manually creates feature_list.json → /sdk-bridge:start → Agent executes
     ↑                                           ↑
     HARD (requires expertise)                   EASY (guided)
```

### Proposed Flow (v3.0)
```
/sdk-bridge:start 
    → "What do you want to build?" (AskUserQuestion)
    → User provides: text OR .md path OR path + focus
    → LLM decomposes task into features (decompose-task skill)
    → User reviews/edits interactively (AskUserQuestion multi-select)
    → Computational validation (dependency_graph.py enhanced)
    → Topological sort + auto-order
    → Generate feature_list.json
    → Continue to existing configuration flow
```

---

## Phase 1: Input Collection (New Step in start.md)

### Objective
After prerequisite checks, ask the user what they want to build before any configuration.

### Input Modes

The system must support three input modes via a single `AskUserQuestion`:

**Question 1: Input Source**
```
question: "How would you like to describe what to build?"
header: "Task Input"
multiSelect: false
options:
  - label: "Type description now"
    description: "Enter a natural language description of what you want to build. Best for simple projects or quick experiments."
  - label: "Point to a .md file"
    description: "Provide a path to a markdown file containing requirements, specs, or a project plan."
  - label: "Point to .md with specific focus"
    description: "Provide a .md file path plus specific instructions about which parts to implement."
```

**If "Type description now":**
- Use second AskUserQuestion with text input
- Example: "Build a REST API for user authentication with JWT tokens and PostgreSQL"

**If "Point to a .md file":**
- Use second AskUserQuestion asking for file path
- Validate file exists and is readable
- Parse full contents for decomposition

**If "Point to .md with specific focus":**
- Use second AskUserQuestion asking for file path
- Use third AskUserQuestion asking for focus instructions
- Example file: `docs/full-spec.md`, focus: "Only implement the authentication module from sections 2-4"

### Design Rationale

Why three modes?
1. **Text input** - Quick for small projects, exploratory work
2. **File path** - Users often have existing specs, PRDs, or plans
3. **File + focus** - Large specs where user wants partial implementation

Why not just text input?
- Text fields in AskUserQuestion are constrained
- Complex projects need more context than a single prompt
- Existing documentation should be reusable

---

## Phase 2: Task Decomposition Skill

### Create New Skill: `decompose-task`

**Location:** `plugins/sdk-bridge/skills/decompose-task/SKILL.md`

**Core Principles (adapted from writing-plans):**

1. **DRY (Don't Repeat Yourself)**
   - Each feature should be unique
   - No overlapping functionality between features
   - Extract common patterns into foundational features

2. **YAGNI (You Aren't Gonna Need It)**
   - Only decompose what the user asked for
   - No speculative features
   - No "nice to have" additions unless explicitly requested
   - Resist over-engineering

3. **TDD-Oriented**
   - Each feature must have testable completion criteria
   - Include `test` field with concrete verification
   - Features should be atomic enough to test independently

4. **Granularity Guidelines**
   - Target 5-25 features for typical projects
   - Each feature = 15-30 minutes of implementation work
   - Too few (< 5) = too coarse, agent overwhelmed
   - Too many (> 30) = micro-management, overhead

### Decomposition Algorithm

The skill instructs Claude to:

1. **Parse Input**
   - Extract core requirements
   - Identify explicit dependencies mentioned
   - Detect technology stack (from keywords, file extensions, or explicit mention)

2. **Layer Identification**
   - Infrastructure layer (setup, config, dependencies)
   - Data layer (schemas, models, migrations)
   - Core logic layer (business rules, algorithms)
   - API/Interface layer (endpoints, UI components)
   - Integration layer (external services, auth)
   - Testing layer (if explicit, otherwise inline)

3. **Feature Generation**
   - Start with infrastructure (these have no dependencies)
   - Build up through layers
   - Explicitly track dependencies
   - Generate unique IDs (feat-NNN format)
   - Write clear, actionable descriptions
   - Include test criteria

4. **Output Format**
   ```json
   {
     "id": "feat-001",
     "description": "Set up Express.js server with basic middleware (cors, json parser)",
     "test": "GET /health returns 200 OK",
     "dependencies": [],
     "tags": ["infrastructure", "backend"],
     "priority": 100,
     "passes": false
   }
   ```

### Anti-Patterns to Avoid

The skill explicitly warns against:
- **Vague features:** "Add authentication" → Must specify mechanism (JWT, session, OAuth)
- **Compound features:** "Add user CRUD" → Split into create, read, update, delete
- **Implicit dependencies:** Must explicitly declare what each feature requires
- **Circular dependencies:** Validator will catch, but avoid in generation
- **Feature bloat:** No features the user didn't ask for

---

## Phase 3: Interactive Review & Edit

### Objective
After LLM generates proposed features, present them for user review before validation.

### Implementation

**Use AskUserQuestion with multi-select:**

```
question: "Review the proposed features. Uncheck any you want to exclude."
header: "Feature Review"
multiSelect: true
options:
  - label: "[feat-001] Set up Express.js server"
    description: "Priority: 100 | Dependencies: none | Test: GET /health returns 200"
    defaultSelected: true
  - label: "[feat-002] Add PostgreSQL connection pool"
    description: "Priority: 90 | Dependencies: feat-001 | Test: Can connect to database"
    defaultSelected: true
  - label: "[feat-003] Create user table migration"
    description: "Priority: 85 | Dependencies: feat-002 | Test: Table exists with correct schema"
    defaultSelected: true
  # ... more features
```

### Edit Capabilities

After initial review, offer edit options:

**Question 2:**
```
question: "Would you like to make any changes?"
header: "Customize"
multiSelect: false
options:
  - label: "Looks good - proceed"
    description: "Accept the selected features and continue to validation"
  - label: "Add more features"
    description: "Describe additional features to add to the list"
  - label: "Edit a feature"
    description: "Modify the description, test, or dependencies of a feature"
  - label: "Regenerate completely"
    description: "Start over with a refined description"
```

**If "Add more features":**
- Ask for description of additional features
- LLM generates new features with proper dependency tracking
- Re-present for review

**If "Edit a feature":**
- Ask which feature to edit (by ID)
- Show current values
- Ask what to change
- Update and re-present

**If "Regenerate completely":**
- Ask for refined description or additional context
- Restart decomposition
- Re-present

---

## Phase 4: Computational Validation

### Enhance `dependency_graph.py`

The existing module handles topological sorting. Enhance it with:

**1. Schema Validation**
```python
def validate_schema(features: List[Dict]) -> ValidationResult:
    """
    Check:
    - Valid JSON array
    - Required fields present: id, description, passes
    - Optional fields typed correctly: dependencies (list), priority (int)
    - No duplicate IDs
    - ID format valid (no spaces, special chars)
    """
```

**2. Dependency Graph Validation**
```python
def validate_dependencies(graph: DependencyGraph) -> ValidationResult:
    """
    Check:
    - All dependency IDs exist in feature list
    - No circular dependencies (detect cycles)
    - No self-dependencies
    - Topological sort possible
    """
```

**3. Granularity Heuristics**
```python
def validate_granularity(features: List[Dict]) -> ValidationResult:
    """
    Warn (not block) if:
    - Too few features (< 3)
    - Too many features (> 50)
    - Description too short (< 10 chars)
    - Description too long (> 200 chars)
    - Missing test criteria
    - Dependency depth > 5 levels
    """
```

### Validation Output

Show validation results to user:
```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
   VALIDATION RESULTS
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

✅ Schema: Valid (12 features, all required fields present)
✅ Dependencies: Valid (no cycles, all refs exist)
⚠️ Granularity: 2 warnings
   - feat-007: Description very short (18 chars)
   - feat-011: Missing test criteria

Proceed anyway? (warnings are non-blocking)
```

---

## Phase 5: Topological Sort & Auto-Order

### Objective
Ensure `feature_list.json` is saved in execution order, not random order.

### Algorithm

1. Build dependency graph from features
2. Run topological sort (already in `dependency_graph.py`)
3. Reorder features array to match sort order
4. Features with no dependencies first
5. Features at same level maintain original order (stable sort)

### Example

**Before sort:**
```json
[
  {"id": "feat-003", "dependencies": ["feat-001", "feat-002"]},
  {"id": "feat-001", "dependencies": []},
  {"id": "feat-002", "dependencies": ["feat-001"]}
]
```

**After topological sort:**
```json
[
  {"id": "feat-001", "dependencies": []},           // Level 0
  {"id": "feat-002", "dependencies": ["feat-001"]}, // Level 1
  {"id": "feat-003", "dependencies": ["feat-001", "feat-002"]}  // Level 2
]
```

### Why This Matters

Even though `hybrid_loop_agent.py` can read dependencies, it processes features sequentially from the array. Correct ordering:
- Ensures foundations built first
- Reduces agent confusion
- Improves human readability
- Required for parallel execution planning

---

## Phase 6: Generate `feature_list.json`

### Output

After validation and sorting, save to project root:

```json
[
  {
    "id": "feat-001",
    "description": "Set up Express.js server with cors and json middleware",
    "test": "GET /health returns 200 OK with {status: 'healthy'}",
    "dependencies": [],
    "tags": ["infrastructure", "backend"],
    "priority": 100,
    "passes": false
  },
  {
    "id": "feat-002",
    "description": "Configure PostgreSQL connection pool with pg-pool",
    "test": "Can execute SELECT 1 query without error",
    "dependencies": ["feat-001"],
    "tags": ["database", "infrastructure"],
    "priority": 90,
    "passes": false
  }
  // ... more features
]
```

### Also Generate

**`.claude/decomposition-log.json`** (for debugging/auditing):
```json
{
  "version": "3.0.0",
  "created_at": "2025-01-17T10:30:00Z",
  "input_mode": "file_with_focus",
  "input_source": "docs/api-spec.md",
  "input_focus": "Implement authentication module only",
  "features_generated": 12,
  "features_accepted": 10,
  "features_excluded": ["feat-008", "feat-012"],
  "validation_warnings": 2,
  "topological_levels": 4
}
```

---

## Integration with Existing `/sdk-bridge:start`

### Modified Flow

The current `start.md` flow:
1. Phase 0: Silent setup detection
2. Phase 0.5: Auto-install/update
3. Phase 1: Prerequisites check ← **Check for feature_list.json here**
4. Phase 2: Interactive configuration
5. Phase 3: Create configuration
6. Phase 4: Launch agent

**Modified flow:**
1. Phase 0: Silent setup detection
2. Phase 0.5: Auto-install/update
3. **Phase 1: Prerequisites check**
   - If `feature_list.json` exists → Ask: "Use existing or create new?"
   - If missing → **Trigger decomposition flow**
4. **Phase 1.5: Decomposition (new)**
   - Input collection
   - Task decomposition
   - Interactive review
   - Validation
   - Generate feature_list.json
5. Phase 2: Interactive configuration (unchanged)
6. Phase 3: Create configuration (unchanged)
7. Phase 4: Launch agent (unchanged)

### Handling Existing `feature_list.json`

When file already exists:
```
question: "Found existing feature_list.json with 15 features. What would you like to do?"
header: "Existing Plan"
multiSelect: false
options:
  - label: "Use existing plan"
    description: "Continue with the current feature_list.json as-is"
  - label: "Review and edit"
    description: "Load current features for review and modification"
  - label: "Create new plan"
    description: "Archive current file and create a fresh decomposition"
```

---

## New Skill: `decompose-task/SKILL.md`

### Full Skill Definition

```markdown
---
name: decompose-task
description: |
  Decompose a high-level task description into structured, executable features
  for SDK Bridge. Emphasizes DRY, YAGNI, TDD principles.
  Use when: user provides task description, .md file, or requirements and needs
  feature_list.json generated.
version: 1.0.0
---

# Task Decomposition for SDK Bridge

Transform natural language task descriptions into structured, dependency-aware
feature lists optimized for autonomous agent execution.

## Core Principles

### DRY (Don't Repeat Yourself)
- Each feature must be unique
- Extract common functionality into shared foundational features
- If two features need the same capability, create a third feature both depend on

### YAGNI (You Aren't Gonna Need It)
- Only decompose what was explicitly requested
- No speculative features or "while we're at it" additions
- Resist over-engineering
- When in doubt, leave it out

### TDD-Oriented Decomposition
- Every feature must have testable completion criteria
- The `test` field is mandatory and must be concrete
- Features should be atomic enough to verify independently
- "Test passes" = "Feature is complete"

## Decomposition Process

### Step 1: Parse Requirements

Extract from input:
- Core functionality requested
- Technology stack (explicit or implied)
- Constraints (performance, security, compatibility)
- Scope boundaries (what's NOT included)

### Step 2: Identify Layers

Standard software layers (apply as relevant):

1. **Infrastructure** (Level 0)
   - Project setup, config files
   - Dependency installation
   - Environment configuration

2. **Data Layer** (Level 1)
   - Database connections
   - Schema/models
   - Migrations

3. **Core Logic** (Level 2)
   - Business rules
   - Algorithms
   - Services

4. **Interface Layer** (Level 3)
   - API endpoints
   - UI components
   - CLI commands

5. **Integration** (Level 4)
   - External APIs
   - Authentication
   - Third-party services

### Step 3: Generate Features

For each identified component:

1. Write clear, actionable description
2. Define concrete test criteria
3. Identify dependencies (features that must complete first)
4. Assign priority (100 = highest, 0 = lowest)
5. Add relevant tags

### Output Format

```json
{
  "id": "feat-NNN",
  "description": "[Action verb] [specific thing] [with details]",
  "test": "[Concrete verification: command output, API response, file exists]",
  "dependencies": ["feat-XXX", "feat-YYY"],
  "tags": ["layer", "domain"],
  "priority": 50,
  "passes": false
}
```

## Granularity Guidelines

### Target Metrics
- **Feature count**: 5-25 for typical projects
- **Implementation time**: 15-30 minutes per feature
- **Description length**: 20-150 characters
- **Test clarity**: Must be verifiable without ambiguity

### Too Coarse (Split It)
❌ "Build authentication system"
✅ Split into: setup, registration, login, logout, password reset, token refresh

### Too Fine (Combine It)
❌ "Create user table", "Add email column", "Add password column"
✅ "Create user table with email and password columns"

### Just Right
✅ "Add JWT token generation on successful login"
✅ "Create /api/users endpoint returning paginated user list"
✅ "Implement password hashing with bcrypt (cost factor 12)"

## Anti-Patterns

### Vague Descriptions
❌ "Add authentication"
✅ "Add JWT-based authentication with 24-hour token expiry"

### Implicit Dependencies
❌ Feature assumes database exists but doesn't declare dependency
✅ Explicitly add `"dependencies": ["feat-002-database-setup"]`

### Compound Features
❌ "Create user CRUD operations"
✅ Four features: create user, get user, update user, delete user

### Missing Tests
❌ `"test": "works correctly"`
✅ `"test": "POST /users with valid data returns 201 and user object with id"`

### Feature Creep
❌ Adding caching, monitoring, analytics when user asked for basic API
✅ Implement exactly what was requested, nothing more

## Example Decomposition

**Input**: "Build a REST API for a todo list with user authentication"

**Output**:
```json
[
  {
    "id": "feat-001",
    "description": "Initialize Node.js project with Express and TypeScript",
    "test": "npm run build succeeds, server starts on port 3000",
    "dependencies": [],
    "tags": ["infrastructure"],
    "priority": 100
  },
  {
    "id": "feat-002",
    "description": "Configure PostgreSQL connection with connection pooling",
    "test": "SELECT 1 query executes successfully",
    "dependencies": ["feat-001"],
    "tags": ["database", "infrastructure"],
    "priority": 95
  },
  {
    "id": "feat-003",
    "description": "Create users table with email, password_hash, created_at",
    "test": "Table exists with correct columns and constraints",
    "dependencies": ["feat-002"],
    "tags": ["database", "auth"],
    "priority": 90
  },
  {
    "id": "feat-004",
    "description": "Implement user registration endpoint POST /api/auth/register",
    "test": "Valid registration returns 201 with user object (no password)",
    "dependencies": ["feat-003"],
    "tags": ["api", "auth"],
    "priority": 85
  },
  {
    "id": "feat-005",
    "description": "Implement user login endpoint POST /api/auth/login with JWT",
    "test": "Valid credentials return 200 with JWT token",
    "dependencies": ["feat-004"],
    "tags": ["api", "auth"],
    "priority": 85
  },
  {
    "id": "feat-006",
    "description": "Create todos table with user_id, title, completed, created_at",
    "test": "Table exists with foreign key to users",
    "dependencies": ["feat-003"],
    "tags": ["database", "todos"],
    "priority": 80
  },
  {
    "id": "feat-007",
    "description": "Implement JWT auth middleware for protected routes",
    "test": "Request without token returns 401, valid token proceeds",
    "dependencies": ["feat-005"],
    "tags": ["middleware", "auth"],
    "priority": 75
  },
  {
    "id": "feat-008",
    "description": "Implement GET /api/todos (list user's todos, paginated)",
    "test": "Returns array of todos belonging to authenticated user",
    "dependencies": ["feat-006", "feat-007"],
    "tags": ["api", "todos"],
    "priority": 70
  },
  {
    "id": "feat-009",
    "description": "Implement POST /api/todos (create new todo)",
    "test": "Creates todo and returns 201 with todo object",
    "dependencies": ["feat-007", "feat-006"],
    "tags": ["api", "todos"],
    "priority": 70
  },
  {
    "id": "feat-010",
    "description": "Implement PATCH /api/todos/:id (update todo)",
    "test": "Updates title/completed, returns 200. 404 if not found/not owner",
    "dependencies": ["feat-008"],
    "tags": ["api", "todos"],
    "priority": 65
  },
  {
    "id": "feat-011",
    "description": "Implement DELETE /api/todos/:id (delete todo)",
    "test": "Deletes todo, returns 204. 404 if not found/not owner",
    "dependencies": ["feat-008"],
    "tags": ["api", "todos"],
    "priority": 65
  }
]
```

Note: 11 features, clear dependencies, concrete tests, logical progression.
```

---

## Implementation Tasks

### Task 1: Create decompose-task Skill
- Create `plugins/sdk-bridge/skills/decompose-task/SKILL.md` (above content)
- Add `examples/decomposition-example.md` with worked examples
- Add `references/granularity-guide.md` with sizing heuristics

### Task 2: Enhance dependency_graph.py
- Add `validate_schema()` function
- Add `validate_granularity()` function with warnings
- Add `reorder_by_topology()` function
- Add CLI flag for standalone validation

### Task 3: Modify start.md
- Add input collection phase after prerequisites
- Integrate decomposition skill invocation
- Add interactive review with AskUserQuestion
- Add validation step
- Handle existing feature_list.json

### Task 4: Create decomposition-log.json Support
- Log input mode, source, decisions
- Track excluded features
- Record validation warnings

### Task 5: Update Documentation
- Update SKILL.md for sdk-bridge-patterns
- Add decomposition workflow to CLAUDE.md
- Update README with new capabilities

### Task 6: Testing
- Test with various input modes (text, file, file+focus)
- Test validation catches errors
- Test topological sort correctness
- Test existing feature_list.json handling

---

## Success Criteria

1. **User can start with no feature_list.json** and complete setup via `/sdk-bridge:start`
2. **Three input modes work**: text, file path, file+focus
3. **Generated features** follow DRY/YAGNI/TDD principles
4. **Validation catches**: missing dependencies, cycles, schema errors
5. **Interactive review** allows add/remove/edit before proceeding
6. **Topologically sorted** output ensures correct execution order
7. **Backward compatible**: existing feature_list.json users unaffected

---

## Migration Path

**v2.x users**: No changes required. `/sdk-bridge:start` still works with existing `feature_list.json`.

**New users**: Can either:
1. Create `feature_list.json` manually (legacy)
2. Let `/sdk-bridge:start` guide them through decomposition (new)

The assisted decomposition is opt-in - triggered only when `feature_list.json` is missing or user chooses "Create new plan."

---

This plan transforms SDK Bridge from requiring expert-level manual planning to providing an end-to-end guided experience while respecting the existing architecture and user preferences.